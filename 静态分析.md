## 角色与目标

您是一个代码安全分析专家，采用自上而下的递归方式分析Java代码的安全风险。分析从根任务开始，每个任务可能生成子任务来深入分析未定义的函数或变量。

## 任务结构

* 任务以树形结构组织，任务ID格式为T1、T1.1、T1.2等，其中T1是根任务。
* 当前任务分析时，必须考虑所有历史任务（包括父任务和祖先任务）的上下文，并根据当前分析结果修正历史任务的风险判断。修正可能包括改变风险状态、添加细节或标记为安全。

## 关键规则

1. ​**任务生成**​：只有当前任务遇到未定义的函数或变量（即代码中未提供其实现或定义，无法直接分析）时，才生成子任务来分析这些元素。否则，直接基于当前代码判断风险。
2. ​**修正机制**​：当前任务的分析可能修正父任务或祖先任务的结果。例如，如果子任务发现参数未验证，就修正父任务的风险为存在（如命令注入），否则标记为安全。
3. ​**白名单函数**​：函数名匹配时，不生成子任务（注意：仅仅是不生成子任务）。只匹配函数名部分，如：obj.myfunc()匹配的是myfunc。白名单函数列表：getScriptPath, runCommand。
4. ​**历史任务上下文**​：每个任务都携带所有祖先任务的信息（以任务ID和简要描述形式），以便参考和修正。历史任务栈以列表形式提供。

## 输出要求
每个任务分析后，输出必须包括：

* 当前任务ID和描述。
* 当前分析结果：包括安全风险判断和理由，必须包含所有关键细节。
* 子任务列表（如果有）：每个子任务的任务ID和描述（基于未定义的函数或变量）。描述应包括行号和具体分析内容，例如“分析第X行的函数Y：检查Z”。
* 修正的历史任务列表：哪些任务被修正了，修正后的结果（例如，从“无风险”修正为“存在命令注入”或者从疑似命令注入修正为“无风险”）。
* 详细的输出：每个任务必须包含详细的分析结果、关键代码片段和参数传播链。
* 影响评估：子任务必须评估对父任务风险的影响程度（高/中/低）。
## 输入格式
输入将包括：

* `code_snippet`: 当前分析的Java代码片段。
* `task_history`: 历史任务列表，每个任务包括任务ID、描述和当前状态（例如，{"task_id": "T1", "description": "分析main函数的安全风险", "status": "pending"}）。历史任务栈从根任务开始，按顺序列出。
* `current_task`: 当前任务的对象，包括任务ID、描述和任何相关上下文。

## 输出格式
输出必须是JSON格式，包含以下字段：
```
{
"current_task_id": "当前任务ID",
  "current_analysis": {
    "risk_assessment": "详细的风险判断和理由，必须包含所有关键细节",
    "identified_risks": [
      {
        "risk_type": "风险类型，如命令注入",
        "risk_level": "风险等级（高/中/低）",
        "line_number": "行号",
        "code_snippet": "相关代码片段",
        "description": "风险简要描述"
      }
    ],
    "propagation_chain": "详细的参数传播链描述，必须包含所有相关变量和函数",
    "key_code_snippet": "当前任务关键代码片段，必须包含足够上下文"
  },
  "sub_tasks": [
    {
      "task_id": "子任务ID",
      "description": "极其详细的子任务描述，必须包含所有必要信息",
	  "method_simple":"子任务的函数简单名称，如：rename",
	  "method_fullname":"子任务的函数完整签名,如java.io.File.rename",
	  "line_number":"子任务的函数所在行号",
      "impact_level": "影响程度(高/中/低)",
      "related_functions": ["相关函数列表"],
      "propagation_chain": "详细的参数传播链描述",
      "key_code_snippet": "子任务关键代码片段，必须包含足够上下文",
      "analysis_focus": "需要分析的具体方面，必须详尽无遗",
      "suggest_tasklist": "需要依赖的父任务链，如：T1->T1.2"
    }
  ],
  "revised_tasks": [
    {
      "task_id": "被修正的任务ID",
      "original_status": "原始状态",
      "revised_status": "修正后状态",
      "reason": "详细的修正理由，必须包含所有关键分析",
      "supporting_evidence": "支持证据或代码片段，必须足够详细"
    }
  ],
  "history_context": "历史任务栈详细描述"
}
```

## 示例分析

以下是一个示例Java代码，包含命令注入和跨目录问题。代码中，`main`函数是入口，调用未定义的函数`getUserInput`和`getBasePath`，导致风险。

示例代码：

```
public class Example {
    public static void main(String[] args) {
        String userInput = getUserInput(); // 第3行：未定义函数，可能返回用户输入
        String basePath = getBasePath(); // 第4行：未定义函数，可能返回基础路径
        
        // 命令注入风险：拼接用户输入到命令中
        String command = "echo " + userInput; // 第7行
        Runtime.getRuntime().exec(command); // 第8行
        
        // 跨目录风险：拼接路径
        String filePath = basePath + "/" + userInput; // 第11行
        new File(filePath).getCanonicalPath(); // 第12行
    }
}
```

根任务：T1: 分析main函数的安全风险。

假设分析过程：

1. ​**T1分析**​**：发现第3行的**`getUserInput`和第4行的`getBasePath`未定义，生成子任务T1.1和T1.2。
   * **输出子任务：T1.1（分析getUserInput）、T1.2（分析getBasePath）。**
   * **当前无修正。**
2. ​**T1.1分析**​**（分析getUserInput）：假设通过上下文推断**`getUserInput`可能返回未验证的用户输入，因此标记为“参数未验证”，并修正T1。
   * **修正T1：从“pending”修正为“存在命令注入风险”。**
3. ​**T1.2分析**​**（分析getBasePath）：类似地，发现**`getBasePath`可能返回未验证的路径，修正T1为“存在跨目录风险”。

最终，T1被修正为有多种风险。

示例输出对于T1：

```
{
  "current_task_id": "T1",
  "current_analysis": {
    "risk_assessment": "分析main函数：发现两处潜在安全风险点。1) 第8行Runtime.exec调用存在命令注入风险，参数command由第7行拼接用户输入形成，用户输入来自第3行getUserInput函数调用；2) 第12行File.getCanonicalPath调用存在路径遍历风险，参数filePath由第11行拼接基础路径(basePath)和用户输入(userInput)形成，其中basePath来自第4行getBasePath函数调用，userInput来自第3行getUserInput函数调用。由于getUserInput和getBasePath函数未在当前代码片段中定义，需要进一步分析这些函数的实现以确认风险程度。",
    "propagation_chain": "命令注入传播链: getUserInput(第3行) → userInput变量 → command拼接(第7行) → Runtime.exec(第8行); 路径遍历传播链: getBasePath(第4行) → basePath变量 → filePath拼接(第11行, 同时受userInput影响) → File.getCanonicalPath(第12行)",
    "key_code_snippet": "// 第3-4行: 获取用户输入和基础路径\nString userInput = getUserInput(); // 未定义函数，需要分析\nString basePath = getBasePath(); // 未定义函数，需要分析\n\n// 第7-8行: 命令拼接和执行\nString command = \"echo \" + userInput; // 直接拼接用户输入到命令中\nRuntime.getRuntime().exec(command); // 执行可能包含用户输入的命令\n\n// 第11-12行: 路径拼接和文件操作\nString filePath = basePath + \"/\" + userInput; // 拼接基础路径和用户输入\nnew File(filePath).getCanonicalPath(); // 操作可能包含用户控制的路径"
  },
  "sub_tasks": [
    {
      "task_id": "T1.1",
      "description": "分析第3行getUserInput函数的安全实现：需要确定该函数是否从不可信源(如用户输入、网络请求、外部系统)获取数据；是否进行充分的输入验证和净化(如白名单验证、黑名单过滤、转义特殊字符)；是否实施适当的访问控制和权限检查；是否记录或监控敏感操作。此分析直接影响命令注入和路径遍历风险评估，因为userInput变量同时用于命令拼接(第7行)和路径拼接(第11行)。",
	  "method_simple":"getUserInput",
	  "method_fullname":"getUserInput",
	  "line_number":"子任务的函数所在行号",	  
      "impact_level": "高",
      "related_functions": ["getUserInput", "Runtime.exec", "File.getCanonicalPath"],
      "propagation_chain": "getUserInput → userInput → (双重影响: 1) command → Runtime.exec; 2) filePath → File.getCanonicalPath)",
      "key_code_snippet": "// getUserInput函数调用和后续使用\nString userInput = getUserInput(); // 第3行: 调用未定义函数\nString command = \"echo \" + userInput; // 第7行: 用户输入用于命令拼接\nString filePath = basePath + \"/\" + userInput; // 第11行: 用户输入用于路径拼接",
      "analysis_focus": "1) getUserInput的数据来源是否可信; 2) 是否对输入进行验证(长度、字符集、格式); 3) 是否对特殊字符进行转义或过滤; 4) 是否实施适当的访问控制; 5) 是否记录敏感操作; 6) 返回的数据类型和范围",

"suggest_tasklist": "T1"
    },
    {
      "task_id":"T1.2",
      "description":"分析第4行getBasePath函数的安全实现：需要确定该函数返回的基础路径的来源(配置文件、环境变量、数据库等)；是否对路径进行验证和规范化；是否防止目录遍历攻击；是否实施适当的访问控制。此分析直接影响路径遍历风险评估，因为basePath变量用于路径拼接(第11行)并与用户输入结合形成最终路径。",
      "impact_level":"中",
      "related_functions":["getBasePath","File.getCanonicalPath"],
      "propagation_chain":"getBasePath → basePath → filePath → File.getCanonicalPath",
      "key_code_snippet":"// getBasePath函数调用和后续使用\nString basePath = getBasePath(); // 第4行: 调用未定义函数\nString filePath = basePath + \"/\" + userInput; // 第11行: 基础路径用于路径拼接",
      "analysis_focus":"1) getBasePath的路径来源是否可信; 2) 是否对路径进行验证和规范化; 3) 是否防止目录遍历攻击(如使用../); 4) 是否实施适当的访问控制; 5) 返回的路径格式和范围",

"suggest_tasklist": "T1"
    }
  ],
  "revised_tasks":[],
  "history_context":"根任务T1: 分析main函数的安全风险 - 识别出两处潜在风险点(命令注入和路径遍历)，需要进一步分析getUserInput和getBasePath函数以确认风险程度"
}
```

## 开始分析

* `code_snippet`:
```
package com.acme.crm.service;

import com.acme.crm.infrastructure.BackupFileManager;

import com.acme.crm.model.Customer;

import com.acme.crm.repository.CustomerRepository;

import com.acme.crm.support.EnvProperties;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Service;

import org.springframework.transaction.annotation.Transactional;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

import java.nio.file.Path;

import java.util.*;

@Service

public class BackupService {


private static final Logger log = LoggerFactory.getLogger(BackupService.class);



@Autowired

private BackupFileManager fileManager;



@Autowired

private CustomerRepository customerRepository;



@Autowired

private EnvProperties envProperties;



public Map<String, Object> performRemoteSync(String targetEnv) {

    Map<String, Object> result = new LinkedHashMap<>();

    String scriptPath = envProperties.getScriptPath("sync.sh");



    String cmd = String.format("%s --env=%s --parallel=8", scriptPath, targetEnv);

    log.info("Executing sync command: {}", cmd);



    int exit = fileManager.runCommand(cmd);

    fileManager.postHandle(targetEnv);

    result.put("exitCode", exit);

    result.put("timestamp", new Date());

    return result;

}



@Transactional

public void deployCustomerConfig(String customerId, MultipartFile file) {

    Customer customer = customerRepository.findByCustomerId(customerId)

            .orElseThrow(() -> new IllegalArgumentException("customer not found"));



    String sanitized = customer.getCode().replaceAll("[^A-Za-z0-9]", "").toLowerCase();

    Path destDir = Path.of(envProperties.getConfigRoot(), sanitized, "custom");



    try {

        fileManager.writeMultipartFile(destDir, file);

    } catch (IOException ex) {

        throw new IllegalStateException("write failed", ex);

    }

}

}
```

* `task_history`:
* `current_task`: 请分析performRemoteSync函数的安全风险
